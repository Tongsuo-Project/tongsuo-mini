/*
 * Copyright 2023 The Tongsuo Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://github.com/Tongsuo-Project/tongsuo-mini/blob/main/LICENSE
 */

#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include "internal/log.h"
#include "internal/sm3.h"
#include <tongsuo/sm3.h>
#include <tongsuo/mem.h>

#define SM3_A 0x7380166fUL
#define SM3_B 0x4914b2b9UL
#define SM3_C 0x172442d7UL
#define SM3_D 0xda8a0600UL
#define SM3_E 0xa96f30bcUL
#define SM3_F 0x163138aaUL
#define SM3_G 0xe38dee4dUL
#define SM3_H 0xb0fb0e4eUL

#define HOST_c2l(c, l)                                                                             \
    (l = (((unsigned long)(*((c)++))) << 24),                                                      \
     l |= (((unsigned long)(*((c)++))) << 16),                                                     \
     l |= (((unsigned long)(*((c)++))) << 8),                                                      \
     l |= (((unsigned long)(*((c)++)))))
#define HOST_l2c(l, c)                                                                             \
    (*((c)++) = (unsigned char)(((l) >> 24) & 0xff),                                               \
     *((c)++) = (unsigned char)(((l) >> 16) & 0xff),                                               \
     *((c)++) = (unsigned char)(((l) >> 8) & 0xff),                                                \
     *((c)++) = (unsigned char)(((l)) & 0xff),                                                     \
     l)

#define ROTATE(a, n)                 (((a) << (n)) | (((a) & 0xffffffff) >> (32 - (n))))

#define P0(X)                        (X ^ ROTATE(X, 9) ^ ROTATE(X, 17))
#define P1(X)                        (X ^ ROTATE(X, 15) ^ ROTATE(X, 23))

#define FF0(X, Y, Z)                 (X ^ Y ^ Z)
#define GG0(X, Y, Z)                 (X ^ Y ^ Z)

#define FF1(X, Y, Z)                 ((X & Y) | ((X | Y) & Z))
#define GG1(X, Y, Z)                 ((Z ^ (X & (Y ^ Z))))

#define EXPAND(W0, W7, W13, W3, W10) (P1(W0 ^ W7 ^ ROTATE(W13, 15)) ^ ROTATE(W3, 7) ^ W10)

#define RND(A, B, C, D, E, F, G, H, TJ, Wi, Wj, FF, GG)                                            \
    do {                                                                                           \
        const unsigned int A12 = ROTATE(A, 12);                                                    \
        const unsigned int A12_SM = A12 + E + TJ;                                                  \
        const unsigned int SS1 = ROTATE(A12_SM, 7);                                                \
        const unsigned int TT1 = FF(A, B, C) + D + (SS1 ^ A12) + (Wj);                             \
        const unsigned int TT2 = GG(E, F, G) + H + SS1 + Wi;                                       \
        B = ROTATE(B, 9);                                                                          \
        D = TT1;                                                                                   \
        F = ROTATE(F, 19);                                                                         \
        H = P0(TT2);                                                                               \
    } while (0)

#define R1(A, B, C, D, E, F, G, H, TJ, Wi, Wj) RND(A, B, C, D, E, F, G, H, TJ, Wi, Wj, FF0, GG0)

#define R2(A, B, C, D, E, F, G, H, TJ, Wi, Wj) RND(A, B, C, D, E, F, G, H, TJ, Wi, Wj, FF1, GG1)

void *tsm_sm3_ctx_new(void)
{
    TSM_SM3_CTX *c = NULL;

    c = tsm_alloc(sizeof(*c));
    if (c == NULL) {
        LOGERR(TSM_ERR_MALLOC_FAILED);
        return NULL;
    }

    return c;
}

void tsm_sm3_ctx_free(void *ctx)
{
    TSM_SM3_CTX *c = ctx;

    if (c == NULL)
        return;

    tsm_memzero(c, sizeof(*c));
    tsm_free(c);
}

int tsm_sm3_init(void *ctx)
{
    TSM_SM3_CTX *c = ctx;

    tsm_memzero(c, sizeof(*c));

    c->A = SM3_A;
    c->B = SM3_B;
    c->C = SM3_C;
    c->D = SM3_D;
    c->E = SM3_E;
    c->F = SM3_F;
    c->G = SM3_G;
    c->H = SM3_H;

    return TSM_OK;
}

void tsm_sm3_transform(void *c, const unsigned char *p, size_t num)
{
    TSM_SM3_CTX *ctx = c;
    const unsigned char *data = p;
    register unsigned int A, B, C, D, E, F, G, H;

    unsigned int W00, W01, W02, W03, W04, W05, W06, W07, W08, W09, W10, W11, W12, W13, W14, W15;

    for (; num--;) {
        A = ctx->A;
        B = ctx->B;
        C = ctx->C;
        D = ctx->D;
        E = ctx->E;
        F = ctx->F;
        G = ctx->G;
        H = ctx->H;

        /*
         * We have to load all message bytes immediately since SM3 reads
         * them slightly out of order.
         */
        (void)HOST_c2l(data, W00);
        (void)HOST_c2l(data, W01);
        (void)HOST_c2l(data, W02);
        (void)HOST_c2l(data, W03);
        (void)HOST_c2l(data, W04);
        (void)HOST_c2l(data, W05);
        (void)HOST_c2l(data, W06);
        (void)HOST_c2l(data, W07);
        (void)HOST_c2l(data, W08);
        (void)HOST_c2l(data, W09);
        (void)HOST_c2l(data, W10);
        (void)HOST_c2l(data, W11);
        (void)HOST_c2l(data, W12);
        (void)HOST_c2l(data, W13);
        (void)HOST_c2l(data, W14);
        (void)HOST_c2l(data, W15);

        R1(A, B, C, D, E, F, G, H, 0x79CC4519, W00, W00 ^ W04);
        W00 = EXPAND(W00, W07, W13, W03, W10);
        R1(D, A, B, C, H, E, F, G, 0xF3988A32, W01, W01 ^ W05);
        W01 = EXPAND(W01, W08, W14, W04, W11);
        R1(C, D, A, B, G, H, E, F, 0xE7311465, W02, W02 ^ W06);
        W02 = EXPAND(W02, W09, W15, W05, W12);
        R1(B, C, D, A, F, G, H, E, 0xCE6228CB, W03, W03 ^ W07);
        W03 = EXPAND(W03, W10, W00, W06, W13);
        R1(A, B, C, D, E, F, G, H, 0x9CC45197, W04, W04 ^ W08);
        W04 = EXPAND(W04, W11, W01, W07, W14);
        R1(D, A, B, C, H, E, F, G, 0x3988A32F, W05, W05 ^ W09);
        W05 = EXPAND(W05, W12, W02, W08, W15);
        R1(C, D, A, B, G, H, E, F, 0x7311465E, W06, W06 ^ W10);
        W06 = EXPAND(W06, W13, W03, W09, W00);
        R1(B, C, D, A, F, G, H, E, 0xE6228CBC, W07, W07 ^ W11);
        W07 = EXPAND(W07, W14, W04, W10, W01);
        R1(A, B, C, D, E, F, G, H, 0xCC451979, W08, W08 ^ W12);
        W08 = EXPAND(W08, W15, W05, W11, W02);
        R1(D, A, B, C, H, E, F, G, 0x988A32F3, W09, W09 ^ W13);
        W09 = EXPAND(W09, W00, W06, W12, W03);
        R1(C, D, A, B, G, H, E, F, 0x311465E7, W10, W10 ^ W14);
        W10 = EXPAND(W10, W01, W07, W13, W04);
        R1(B, C, D, A, F, G, H, E, 0x6228CBCE, W11, W11 ^ W15);
        W11 = EXPAND(W11, W02, W08, W14, W05);
        R1(A, B, C, D, E, F, G, H, 0xC451979C, W12, W12 ^ W00);
        W12 = EXPAND(W12, W03, W09, W15, W06);
        R1(D, A, B, C, H, E, F, G, 0x88A32F39, W13, W13 ^ W01);
        W13 = EXPAND(W13, W04, W10, W00, W07);
        R1(C, D, A, B, G, H, E, F, 0x11465E73, W14, W14 ^ W02);
        W14 = EXPAND(W14, W05, W11, W01, W08);
        R1(B, C, D, A, F, G, H, E, 0x228CBCE6, W15, W15 ^ W03);
        W15 = EXPAND(W15, W06, W12, W02, W09);
        R2(A, B, C, D, E, F, G, H, 0x9D8A7A87, W00, W00 ^ W04);
        W00 = EXPAND(W00, W07, W13, W03, W10);
        R2(D, A, B, C, H, E, F, G, 0x3B14F50F, W01, W01 ^ W05);
        W01 = EXPAND(W01, W08, W14, W04, W11);
        R2(C, D, A, B, G, H, E, F, 0x7629EA1E, W02, W02 ^ W06);
        W02 = EXPAND(W02, W09, W15, W05, W12);
        R2(B, C, D, A, F, G, H, E, 0xEC53D43C, W03, W03 ^ W07);
        W03 = EXPAND(W03, W10, W00, W06, W13);
        R2(A, B, C, D, E, F, G, H, 0xD8A7A879, W04, W04 ^ W08);
        W04 = EXPAND(W04, W11, W01, W07, W14);
        R2(D, A, B, C, H, E, F, G, 0xB14F50F3, W05, W05 ^ W09);
        W05 = EXPAND(W05, W12, W02, W08, W15);
        R2(C, D, A, B, G, H, E, F, 0x629EA1E7, W06, W06 ^ W10);
        W06 = EXPAND(W06, W13, W03, W09, W00);
        R2(B, C, D, A, F, G, H, E, 0xC53D43CE, W07, W07 ^ W11);
        W07 = EXPAND(W07, W14, W04, W10, W01);
        R2(A, B, C, D, E, F, G, H, 0x8A7A879D, W08, W08 ^ W12);
        W08 = EXPAND(W08, W15, W05, W11, W02);
        R2(D, A, B, C, H, E, F, G, 0x14F50F3B, W09, W09 ^ W13);
        W09 = EXPAND(W09, W00, W06, W12, W03);
        R2(C, D, A, B, G, H, E, F, 0x29EA1E76, W10, W10 ^ W14);
        W10 = EXPAND(W10, W01, W07, W13, W04);
        R2(B, C, D, A, F, G, H, E, 0x53D43CEC, W11, W11 ^ W15);
        W11 = EXPAND(W11, W02, W08, W14, W05);
        R2(A, B, C, D, E, F, G, H, 0xA7A879D8, W12, W12 ^ W00);
        W12 = EXPAND(W12, W03, W09, W15, W06);
        R2(D, A, B, C, H, E, F, G, 0x4F50F3B1, W13, W13 ^ W01);
        W13 = EXPAND(W13, W04, W10, W00, W07);
        R2(C, D, A, B, G, H, E, F, 0x9EA1E762, W14, W14 ^ W02);
        W14 = EXPAND(W14, W05, W11, W01, W08);
        R2(B, C, D, A, F, G, H, E, 0x3D43CEC5, W15, W15 ^ W03);
        W15 = EXPAND(W15, W06, W12, W02, W09);
        R2(A, B, C, D, E, F, G, H, 0x7A879D8A, W00, W00 ^ W04);
        W00 = EXPAND(W00, W07, W13, W03, W10);
        R2(D, A, B, C, H, E, F, G, 0xF50F3B14, W01, W01 ^ W05);
        W01 = EXPAND(W01, W08, W14, W04, W11);
        R2(C, D, A, B, G, H, E, F, 0xEA1E7629, W02, W02 ^ W06);
        W02 = EXPAND(W02, W09, W15, W05, W12);
        R2(B, C, D, A, F, G, H, E, 0xD43CEC53, W03, W03 ^ W07);
        W03 = EXPAND(W03, W10, W00, W06, W13);
        R2(A, B, C, D, E, F, G, H, 0xA879D8A7, W04, W04 ^ W08);
        W04 = EXPAND(W04, W11, W01, W07, W14);
        R2(D, A, B, C, H, E, F, G, 0x50F3B14F, W05, W05 ^ W09);
        W05 = EXPAND(W05, W12, W02, W08, W15);
        R2(C, D, A, B, G, H, E, F, 0xA1E7629E, W06, W06 ^ W10);
        W06 = EXPAND(W06, W13, W03, W09, W00);
        R2(B, C, D, A, F, G, H, E, 0x43CEC53D, W07, W07 ^ W11);
        W07 = EXPAND(W07, W14, W04, W10, W01);
        R2(A, B, C, D, E, F, G, H, 0x879D8A7A, W08, W08 ^ W12);
        W08 = EXPAND(W08, W15, W05, W11, W02);
        R2(D, A, B, C, H, E, F, G, 0x0F3B14F5, W09, W09 ^ W13);
        W09 = EXPAND(W09, W00, W06, W12, W03);
        R2(C, D, A, B, G, H, E, F, 0x1E7629EA, W10, W10 ^ W14);
        W10 = EXPAND(W10, W01, W07, W13, W04);
        R2(B, C, D, A, F, G, H, E, 0x3CEC53D4, W11, W11 ^ W15);
        W11 = EXPAND(W11, W02, W08, W14, W05);
        R2(A, B, C, D, E, F, G, H, 0x79D8A7A8, W12, W12 ^ W00);
        W12 = EXPAND(W12, W03, W09, W15, W06);
        R2(D, A, B, C, H, E, F, G, 0xF3B14F50, W13, W13 ^ W01);
        W13 = EXPAND(W13, W04, W10, W00, W07);
        R2(C, D, A, B, G, H, E, F, 0xE7629EA1, W14, W14 ^ W02);
        W14 = EXPAND(W14, W05, W11, W01, W08);
        R2(B, C, D, A, F, G, H, E, 0xCEC53D43, W15, W15 ^ W03);
        W15 = EXPAND(W15, W06, W12, W02, W09);
        R2(A, B, C, D, E, F, G, H, 0x9D8A7A87, W00, W00 ^ W04);
        W00 = EXPAND(W00, W07, W13, W03, W10);
        R2(D, A, B, C, H, E, F, G, 0x3B14F50F, W01, W01 ^ W05);
        W01 = EXPAND(W01, W08, W14, W04, W11);
        R2(C, D, A, B, G, H, E, F, 0x7629EA1E, W02, W02 ^ W06);
        W02 = EXPAND(W02, W09, W15, W05, W12);
        R2(B, C, D, A, F, G, H, E, 0xEC53D43C, W03, W03 ^ W07);
        W03 = EXPAND(W03, W10, W00, W06, W13);
        R2(A, B, C, D, E, F, G, H, 0xD8A7A879, W04, W04 ^ W08);
        R2(D, A, B, C, H, E, F, G, 0xB14F50F3, W05, W05 ^ W09);
        R2(C, D, A, B, G, H, E, F, 0x629EA1E7, W06, W06 ^ W10);
        R2(B, C, D, A, F, G, H, E, 0xC53D43CE, W07, W07 ^ W11);
        R2(A, B, C, D, E, F, G, H, 0x8A7A879D, W08, W08 ^ W12);
        R2(D, A, B, C, H, E, F, G, 0x14F50F3B, W09, W09 ^ W13);
        R2(C, D, A, B, G, H, E, F, 0x29EA1E76, W10, W10 ^ W14);
        R2(B, C, D, A, F, G, H, E, 0x53D43CEC, W11, W11 ^ W15);
        R2(A, B, C, D, E, F, G, H, 0xA7A879D8, W12, W12 ^ W00);
        R2(D, A, B, C, H, E, F, G, 0x4F50F3B1, W13, W13 ^ W01);
        R2(C, D, A, B, G, H, E, F, 0x9EA1E762, W14, W14 ^ W02);
        R2(B, C, D, A, F, G, H, E, 0x3D43CEC5, W15, W15 ^ W03);

        ctx->A ^= A;
        ctx->B ^= B;
        ctx->C ^= C;
        ctx->D ^= D;
        ctx->E ^= E;
        ctx->F ^= F;
        ctx->G ^= G;
        ctx->H ^= H;
    }
}

int tsm_sm3_update(void *ctx, const unsigned char *data, size_t len)
{
    TSM_SM3_CTX *c = ctx;
    unsigned char *p;
    unsigned int l;
    size_t n;

    if (len == 0)
        return TSM_OK;

    l = (c->Nl + (((unsigned int)len) << 3)) & 0xffffffffUL;
    if (l < c->Nl) /* overflow */
        c->Nh++;
    c->Nh += (unsigned int)(len >> 29); /* might cause compiler warning on
                                         * 16-bit */
    c->Nl = l;

    n = c->num;
    if (n != 0) {
        p = (unsigned char *)c->data;

        if (len >= TSM_SM3_CBLOCK || len + n >= TSM_SM3_CBLOCK) {
            memcpy(p + n, data, TSM_SM3_CBLOCK - n);
            tsm_sm3_transform(c, p, 1);
            n = TSM_SM3_CBLOCK - n;
            data += n;
            len -= n;
            c->num = 0;
            tsm_memzero(p, TSM_SM3_CBLOCK); /* keep it zeroed */
        } else {
            memcpy(p + n, data, len);
            c->num += (unsigned int)len;
            return TSM_OK;
        }
    }

    n = len / TSM_SM3_CBLOCK;
    if (n > 0) {
        tsm_sm3_transform(c, data, n);
        n *= TSM_SM3_CBLOCK;
        data += n;
        len -= n;
    }

    if (len != 0) {
        p = (unsigned char *)c->data;
        c->num = (unsigned int)len;
        memcpy(p, data, len);
    }
    return TSM_OK;
}

int tsm_sm3_final(void *ctx, unsigned char *md, size_t *mdlen)
{
    TSM_SM3_CTX *c = ctx;
    unsigned char *p = (unsigned char *)c->data;
    size_t n = c->num;
    unsigned long ll;

    p[n] = 0x80;
    n++;

    if (n > (TSM_SM3_CBLOCK - 8)) {
        memset(p + n, 0, TSM_SM3_CBLOCK - n);
        n = 0;
        tsm_sm3_transform(c, p, 1);
    }
    memset(p + n, 0, TSM_SM3_CBLOCK - 8 - n);

    p += TSM_SM3_CBLOCK - 8;
    (void)HOST_l2c(c->Nh, p);
    (void)HOST_l2c(c->Nl, p);
    p -= TSM_SM3_CBLOCK;
    tsm_sm3_transform(c, p, 1);
    c->num = 0;
    tsm_memzero(p, TSM_SM3_CBLOCK);

    ll = c->A;
    (void)HOST_l2c(ll, md);
    ll = c->B;
    (void)HOST_l2c(ll, md);
    ll = c->C;
    (void)HOST_l2c(ll, md);
    ll = c->D;
    (void)HOST_l2c(ll, md);
    ll = c->E;
    (void)HOST_l2c(ll, md);
    ll = c->F;
    (void)HOST_l2c(ll, md);
    ll = c->G;
    (void)HOST_l2c(ll, md);
    ll = c->H;
    (void)HOST_l2c(ll, md);

    if (mdlen)
        *mdlen = TSM_SM3_DIGEST_LEN;

    return TSM_OK;
}

int tsm_sm3_oneshot(const unsigned char *data, size_t len, unsigned char *md)
{
    int ret;
    TSM_SM3_CTX *ctx = NULL;

    ctx = tsm_sm3_ctx_new();
    if (ctx == NULL)
        return eLOG(TSM_ERR_MALLOC_FAILED);

    if ((ret = tsm_sm3_init(ctx)) != TSM_OK || (ret = tsm_sm3_update(ctx, data, len)) != TSM_OK
        || (ret = tsm_sm3_final(ctx, md, NULL)) != TSM_OK) {
        tsm_sm3_ctx_free(ctx);
        return ret;
    }

    tsm_sm3_ctx_free(ctx);
    return TSM_OK;
}
